from typing import Any, List

from sqlalchemy.types import Integer, String
from sqlalchemy.schema import Table, Column, ForeignKey
from sqlalchemy.ext.declarative import declared_attr
from sqlalchemy.orm import relationship, backref
from sqlalchemy.event import listen
from sqlalchemy import inspect


def resource_role_class(declarative_base, user_model, resource_model, role_choices):
    tablename = f"{resource_model.__name__.lower()}_roles"

    class ResourceRoleMixin:
        choices = role_choices

        __tablename__ = tablename
        id = Column(Integer, primary_key=True)
        name = Column(String())

        @declared_attr
        def user_id(cls):
            type = inspect(user_model).primary_key[0].type
            name = inspect(user_model).primary_key[0].name
            table_name = user_model.__tablename__
            return Column(type, ForeignKey(f"{table_name}.{name}"))

        @declared_attr
        def user(cls):
            return relationship(user_model.__name__, backref=tablename, lazy=True)

        @staticmethod
        def before_set_name(target, value, oldvalue, initiator):
            if value not in role_choices:
                raise ValueError(
                    f"{value} Is not a valid choice for {resource_model.__name__} Roles"
                )

    @declared_attr
    def resource_id(cls):
        type = inspect(resource_model).primary_key[0].type
        name = inspect(resource_model).primary_key[0].name
        table_name = resource_model.__tablename__
        return Column(type, ForeignKey(f"{table_name}.{name}"))

    @declared_attr
    def resource(cls):
        return relationship(resource_model.__name__, backref="roles", lazy=True)

    setattr(ResourceRoleMixin, f"{resource_model.__name__.lower()}_id", resource_id)
    setattr(ResourceRoleMixin, resource_model.__name__.lower(), resource)

    # Add the relationship between the user_model and the resource_model
    resources = relationship(
        resource_model.__name__,
        secondary=tablename,
        lazy=True,
        viewonly=True,
        backref="users",
        sync_backref=False,
    )
    # @Q: Do we try to pluralize this name correctly?
    setattr(user_model, resource_model.__name__.lower() + "s", resources)

    return ResourceRoleMixin


ROLE_CLASSES: List[Any] = []


def enable_roles():

    # @TODO: Need to set up this listener somehow.
    # listen(ResourceRoleMixin.name, "set", ResourceRoleMixin.before_set_name, propigate=True)

    pass


# def enable_roles(oso):
#     """Enable the SQLAlchemy Role-Based Access Control base policy. This method activates the following polar rules:

#     ``role_allow(role, action, resource)``:
#         Allows actors that have the role ``role`` to take ``action`` on
#         ``resource``. ``role`` is a SQLAlchemy role model generated by
#         :py:meth:`sqlalchemy_oso.roles.resource_role_class`. ``resource``
#         is a SQLAlchemy model to which the ``role`` applies. Roles apply
#         to the resources they are scoped to, For example,
#         ``OrganizationRole`` roles apply to ``Organization`` resources.
#         Roles may also apply to resources as specified by
#         ``resource_role_applies_to`` Polar rules. E.g.,

#         .. code-block:: polar

#             role_allow(role: OrganizationRole{name: "MEMBER"}, "READ", org: Organization);


#     ``resource_role_applies_to(child_resource, parent_resource)``:
#         Permits roles that control access to `parent_resource` apply to
#         `child_resource` as well. `parent_resource` must be a resource
#         that has a resource role class associated with it (see
#         :py:meth:`sqlalchemy_oso.roles.resource_role_class`). E.g.,

#         .. code-block:: polar

#             ### An organization's roles apply to its child repositories
#             resource_role_applies_to(repo: Repository, parent_org) if
#                 parent_org = repo.organization;

#         The above rule makes it possible to write `role_allow` rules
#         between `OrganizationRole` and `Repository`. E.g.,

#         .. code-block:: polar

#             role_allow(role: OrganizationRole{name: "MEMBER"}, "READ", repo: Repository);

#     ``[resource_name]_role_order(["ROLE_NAME_1", "ROLE_NAME_2",...])``:
#         Specifies a hierarchical role order for built-in
#         resource-specific roles defined with
#         :py:meth:`sqlalchemy_oso.roles.resource_role_class` The rule name
#         is the lower-cased resource model name followed by
#         ``_role_order``. The only parameter is a list of role names in
#         hierarchical order. Roles to the left will inherit the
#         permissions of roles to the right. This is useful if any role
#         should inherit all the permissions of another role. It is not
#         required for all built-in roles to be specified in the list. E.g.,

#         .. code-block:: polar

#             repository_role_order(["ADMIN", "MAINTAIN", "WRITE", "TRIAGE", "READ"]);

#         Is the equivalent of writing:

#         .. code-block:: polar

#             role_allow(role: RepositoryRole{name: "ADMIN"}, _action, _resource) if
#                 role_allow(new RepositoryRole{name: "MAINTAIN"}, _action, _resource);

#             role_allow(role: RepositoryRole{name: "MAINTAIN"}, _action, _resource) if
#                 role_allow(new RepositoryRole{name: "WRITE"}, _action, _resource);

#         ...and so on.


#     :param oso: The Oso instance used to evaluate the policy.
#     :type oso: Oso
#     """

#     global ROLE_CLASSES

#     policy = """
#     # RBAC BASE POLICY

#     ## Top-level RBAC allow rule

#     allow(user, action, resource) if
#         rbac_allow(user, action, resource);

#     ### The association between the resource roles and the requested resource is outsourced from the rbac_allow
#     rbac_allow(user, action, resource) if
#         resource_role_applies_to(resource, role_resource) and
#         user_in_role(user, role, role_resource) and
#         role_allow(role, action, resource);

#     # RESOURCE-ROLE RELATIONSHIPS

#     ## These rules allow roles to apply to resources other than those that they are scoped to.
#     ## The most common example of this is nested resources, e.g. Repository roles should apply to the Issues
#     ## nested in that repository.

#     ### A resource's roles applies to itself
#     resource_role_applies_to(role_resource, role_resource);

#     # ROLE-ROLE RELATIONSHIPS

#     ## Role Hierarchies

#     ### Grant a role permissions that it inherits from a more junior role
#     role_allow(role, action, resource) if
#         inherits_role(role, inherited_role) and
#         role_allow(inherited_role, action, resource);

#     ### Helper to determine relative order or roles in a list
#     inherits_role_helper(role, inherited_role, role_order) if
#         ([first, *rest] = role_order and
#         role = first and
#         inherited_role in rest) or
#         ([first, *rest] = role_order and
#         inherits_role_helper(role, inherited_role, rest));
#     """

#     for role_model in ROLE_CLASSES:
#         User = role_model["user_model"].__name__
#         Resource = role_model["resource_model"].__name__
#         Role = role_model["role_model"]

#         policy += f"""
#         user_in_role(user: {User}, role, resource: {Resource}) if
#             session = OsoSession.get() and
#             role in session.query({Role}).filter({Role}.users.any({User}.id.__eq__(user.id))) and
#             role.{Resource.lower()}.id = resource.id;

#         inherits_role(role: {Role}, inherited_role) if
#             {Resource.lower()}_role_order(role_order) and
#             inherits_role_helper(role.name, inherited_role_name, role_order) and
#             inherited_role = new {Role}(name: inherited_role_name, {Resource.lower()}: role.{Resource.lower()});
#         """
#     oso.load_str(policy)


# def resource_role_class(declarative_base, user_model, resource_model, roles):
#     """Create a :ref:`resource-specific role<resource-specific-roles>` Mixin
#     for SQLAlchemy models. Returns the role mixin, which must then be mixed
#     into a SQLAlchemy model for the role. E.g.,

#     .. code-block:: python

#         OrganizationRoleMixin = oso_roles.resource_role_class(
#             Base, User, Organization, ["OWNER", "MEMBER", "BILLING"]
#         )

#         class OrganizationRole(Base, OrganizationRoleMixin):
#             pass


#     :param declarative_base: The SQLAlchemy declarative base model that \
#     the role model and all related models are mapped to.

#     :param user_model: The SQLAlchemy model representing users that the \
#     resource-specific roles can be assigned to. The generated Role mixin will \
#     have a many-to-many relationship with this user model. The primary key of \
#     the ``user_model`` must be named ``id``. E.g.,

#         .. code-block:: python

#             class User(Base):
#                 __tablename__ = "users"

#                 id = Column(Integer, primary_key=True)
#                 email = Column(String())

#     :param resource_model: The SQLAlchemy model representing resources that \
#     the generated Role mixin will be scoped to. The Role mixin will \
#     have a many-to-one (ForeignKey) relationship with this resource model. \
#     The primary key of the ``resource_model`` must be named ``id``. E.g.,

#         .. code-block:: python

#             class Repository(Base):
#                 __tablename__ = "repositories"

#                 id = Column(Integer, primary_key=True)
#                 name = Column(String(256))

#     :param roles: An order-independent list of the built-in roles for this resource-specific role type.
#     :type roles: List[str]

#         .. code-block:: python

#             class Team(Base):
#                 __tablename__ = "teams"

#                 id = Column(Integer, primary_key=True)
#                 name = Column(String(256))


#     """
#     global ROLE_CLASSES
#     ROLE_CLASSES.append(
#         {
#             "user_model": user_model,
#             "resource_model": resource_model,
#             # @NOTE: Must name role model like this for now.
#             "role_model": resource_model.__name__ + "Role",
#         }
#     )

#     # many-to-many relationship with users
#     user_join_table = Table(
#         f"{resource_model.__name__.lower()}_roles_users",
#         declarative_base.metadata,
#         Column(
#             f"{resource_model.__name__.lower()}_role_id",
#             Integer,
#             ForeignKey(f"{resource_model.__name__.lower()}_roles.id"),
#             primary_key=True,
#         ),
#         Column(
#             "user_id",
#             Integer,
#             ForeignKey(f"{user_model.__tablename__}.id"),
#             primary_key=True,
#         ),
#     )

#     class ResourceRoleMixin:
#         # TODO: enforce that classes are named with the ResourceRole convention, e.g. RepositoryRole
#         choices = roles

#         __tablename__ = f"{resource_model.__name__.lower()}_roles"
#         id = Column(Integer, primary_key=True)
#         name = Column(String())

#         # many-to-many relationship with users
#         @declared_attr
#         def users(cls):
#             return relationship(
#                 f"{user_model.__name__}",
#                 secondary=user_join_table,
#                 lazy="subquery",
#                 backref=backref(f"{resource_model.__name__.lower()}_roles", lazy=True),
#             )

#     @declared_attr
#     def resource_id(cls):
#         table_name = resource_model.__tablename__
#         return Column(Integer, ForeignKey(f"{table_name}.id"))

#     @declared_attr
#     def resource(cls):
#         return relationship(resource_model.__name__, backref="roles", lazy=True)

#     setattr(ResourceRoleMixin, f"{resource_model.__name__.lower()}_id", resource_id)
#     setattr(ResourceRoleMixin, resource_model.__name__.lower(), resource)

#     return ResourceRoleMixin


# ROLE HELPER METHODS


def get_role_model_for_resource_model(resource_model):
    return inspect(resource_model).relationships.get("roles").argument.class_


def get_user_model_for_resource_model(resource_model):
    role_model = get_role_model_for_resource_model(resource_model)
    return inspect(role_model).relationships.get("users").argument()


def get_user_resources_and_roles(session, user, resource_model):
    """Get a user's roles for all resources of a single resource type.
    E.g., get all of a user's repositories and their role for each
    repository.

    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param user: user record (python object) of the SQLAlchemy user model \
    associated with roles scoped to the supplied ``resource_model``

    :param resource_model: the resource model (python class) for which to get \
    the user's roles

    :return: List of (resource, role) tuples for every role the user has \
    associated with the ``resource_model``
    """
    role_model = get_role_model_for_resource_model(resource_model)
    user_model = type(user)
    resource_roles = (
        session.query(resource_model, role_model)
        .join(role_model)
        .filter(role_model.users.any(user_model.id == user.id))
        .order_by(resource_model.id)
        .order_by(role_model.name)
        .all()
    )
    return resource_roles


def get_user_roles_for_resource(session, user, resource):
    """Get a user's roles for a single resource record. E.g., get all the
    roles a user has for Organization 1.

    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param user: user record (python object) of the SQLAlchemy user model \
    associated with roles scoped to the model of the supplied ``resource``

    :param resource: the resource record (python object) for which to get \
    the user's roles

    :return: List of all role objects the user has \
    associated with the ``resource``

    """
    resource_model = type(resource)
    role_model = get_role_model_for_resource_model(resource_model)
    user_model = type(user)
    roles = (
        session.query(role_model)
        .filter(role_model.users.any(user_model.id == user.id))
        .all()
    )
    return roles


# - Get an organization's users and their roles
def get_resource_users_and_roles(session, resource):
    """Get all of the users and their roles for a specific resource. E.g.,
    get all the users in Organization 1 and their roles in the
    organization.


    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param resource: the resource record (python object) for which to get \
    the users and roles

    :return: List of (user, role) tuples for every user associated with \
    the ``resource``

    """
    resource_model = type(resource)
    role_model = get_role_model_for_resource_model(resource_model)
    user_model = get_user_model_for_resource_model(resource_model)
    user_roles = (
        session.query(user_model, role_model)
        .select_from(role_model)
        .join(role_model.users)
        .join(resource_model)
        .filter(resource_model.id == resource.id)
        .order_by(user_model.id)
        .order_by(role_model.name)
        .all()
    )
    return user_roles


# - Get all the users who have a specific role
def get_resource_users_with_role(session, resource, role_name):
    """Get all of the users that have a specific role for a specific
    resource. E.g., get all the users in Organization 1 that have the "OWNER"
    role.

    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param resource: the resource record (python object) for which to get \
    the users

    :param role_name: the name of the role to get users for
    :type role_name: str

    :return: List of users that have the ``role_name`` role for \
    ``resource``

    """
    resource_model = type(resource)
    role_model = get_role_model_for_resource_model(resource_model)
    user_model = get_user_model_for_resource_model(resource_model)

    users = (
        session.query(user_model)
        .select_from(role_model)
        .join(role_model.users)
        .join(resource_model)
        .filter(role_model.name == role_name, resource_model.id == resource.id)
        .order_by(user_model.id)
        .all()
    )

    return users


# - Assign a user to an organization with a role
def add_user_role(session, user, resource, role_name):
    """Add a user to a role for a specific resource.

    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param user: user record (python object) to assign the role to

    :param role_name: the name of the role to assign to the user
    :type role_name: str
    """
    resource_model = type(resource)
    role_model = get_role_model_for_resource_model(resource_model)

    if role_name not in role_model.choices:
        raise Exception(
            f"{role_name} Is not a valid choice for {resource.__class__.__name__} Roles"
        )

    # try to get role
    role = (
        session.query(role_model)
        .select_from(resource_model)
        .join(role_model)
        .filter(resource_model.id == resource.id)
        .filter(role_model.name == role_name)
    ).first()

    if role:
        # TODO: check if user already in role
        role.users.append(user)
    else:
        resource_name = resource_model.__name__.lower()
        kwargs = {"name": role_name, resource_name: resource, "users": [user]}

        role = role_model(**kwargs)
        session.add(role)
        session.commit()


# - Delete a user to an organization with a role
def delete_user_role(session, user, resource, role_name=None):
    """Remove a user from a role for a specific resource.

    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param user: user record (python object) to remove the role from

    :param role_name: the name of the role to remove from the user. If not \
    provided, the function will remove all roles the user has for \
    ``resource``.
    :type role_name: str
    """
    resource_model = type(resource)
    role_model = get_role_model_for_resource_model(resource_model)
    user_model = type(user)

    role_query = (
        session.query(role_model)
        .select_from(resource_model)
        .join(role_model)
        .filter(resource_model.id == resource.id)
    )
    if role_name:
        role_query = role_query.filter(role_model.name == role_name)
    else:
        role_query = role_query.filter(role_model.users.any(user_model.id == user.id))

    roles = role_query.all()

    for role in roles:
        try:
            role.users.remove(user)
        except ValueError:
            raise Exception(f"User {user.id} not in role {role.name} for {resource.id}")


# - Change the user's role in an organization
def reassign_user_role(session, user, resource, role_name):
    """Remove all existing roles that a user has for a specific resource, and
    reassign the user to a new role. If the user does not have any roles for
    the given resource, the behavior is the same as
    :py:meth:`sqlalchemy_oso.roles.add_user_role`.

    :param session: SQLAlchemy session
    :type session: sqlalchemy.orm.session.Session

    :param user: user record (python object) whose role should be reassigned

    :param role_name: the name of the new role to assign to the user
    :type role_name: str
    """
    delete_user_role(session, user, resource)
    add_user_role(session, user, resource, role_name)
