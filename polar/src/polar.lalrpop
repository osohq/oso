// @NOTE(steve): This was pretty easy to get running but the error messages you get when things don't parse aren't as
// good as what we want to expose to polar users. Either we do a lot of mapping or we replace this with a hand rolled
// parser later.

use std::str::FromStr;
use std::collections::{HashMap, BTreeMap};
use std::rc::Rc;

use crate::lexer::{self, Token};
use crate::parser::Line;
use crate::error;
use crate::types::*;

use lalrpop_util::ParseError;

grammar;

extern {
    type Location = usize;
    type Error = error::ParseError;

    enum Token {
        "Integer" => lexer::Token::Integer(<i64>),
        "Float" => lexer::Token::Float(<f64>),
        "String" => lexer::Token::String(<String>),
        "Boolean" => lexer::Token::Boolean(<bool>),
        "Symbol" => lexer::Token::Symbol(<Symbol>),
        ":" => lexer::Token::Colon,     // :
        "," => lexer::Token::Comma,     // ,
        "[" => lexer::Token::LB,        // [
        "]" => lexer::Token::RB,        // ]
        "(" => lexer::Token::LP,        // (
        ")" => lexer::Token::RP,        // )
        "{" => lexer::Token::LCB,       // {
        "}" => lexer::Token::RCB,       // }
        "." => lexer::Token::Dot,       // .
        "new" => lexer::Token::New,     // new
        "!" => lexer::Token::Not,       // !
        "*" => lexer::Token::Mul,       // *
        "/" => lexer::Token::Div,       // /
        "+" => lexer::Token::Add,       // +
        "-" => lexer::Token::Sub,       // -
        "==" => lexer::Token::Eq,       // ==
        "!=" => lexer::Token::Neq,      // !=
        "<=" => lexer::Token::Leq,      // <=
        ">=" => lexer::Token::Geq,      // >=
        "<" => lexer::Token::Lt,        // <
        ">" => lexer::Token::Gt,        // >
        "=" => lexer::Token::Unify,     // =
        "|" => lexer::Token::Pipe,      // |
        ";" => lexer::Token::SemiColon, // ;
        ":=" => lexer::Token::Define,   // :=
        "?=" => lexer::Token::Query,    // ?=
        "cut" => lexer::Token::Cut,
        "debug" => lexer::Token::Debug,
        "in" => lexer::Token::In,       // in
        "isa" => lexer::Token::Isa,     // isa
        "forall" => lexer::Token::ForAll,     // forall
    }
}

pub Number: Rc<Term> = {
    <start:@L> <i:"Integer"> => {
        Rc::new(Term{id: 0, offset: start, value: Value::Number(i.into())})
    },
    <start:@L> <f:"Float"> => {
        Rc::new(Term{id: 0, offset: start, value: Value::Number(f.into())})
    }
};


pub PolarString: Rc<Term> = <start:@L> <s:"String"> => {
    Rc::new(Term{id: 0, offset: start, value: Value::String(s)})
};

pub Boolean: Rc<Term> = <start:@L> <b:"Boolean"> => {
    Rc::new(Term{id: 0, offset: start, value: Value::Boolean(b)})
};

Name: Symbol = <s:"Symbol"> => s;

pub Symbol: Rc<Term>  = <start:@L> <n:Name> => {
    Rc::new(Term{id: 0, offset: start, value: Value::Symbol(n)})
};

Fields<T>: Fields = {
    <name:Name> ":" <value:T> => {
        let mut fields = BTreeMap::new();
        fields.insert(name, value);
        fields
    },
    <name:Name> ":" <value:T> "," <mut fields:Fields<T>> => {
        fields.insert(name, value);
        fields
    }
};

Object<T>: Fields = {
    "{" <fields:Fields<T>> "}" => {
        fields
    },
    "{" "}" => {
        BTreeMap::new()
    }
};

Dictionary<T>: Rc<Term> = <start:@L> <fields:Object<T>> => {
    let dict = Dictionary{fields};
    Rc::new(Term{id: 0, offset: start, value: Value::Dictionary(dict)})
};

DictionaryTerm: Rc<Term> = <Dictionary<Exp5<"Term">>> => <>;
// Pattern dictionaries cannot contain any operators.
DictionaryPattern: Rc<Term> = <Dictionary<Exp9<"Pattern">>> => <>;

InstanceLiteral<T>: Rc<Term> = <start:@L> <tag:Name> <fields:Object<T>> => {
    let instance = InstanceLiteral{tag, fields: Dictionary{fields}};
    Rc::new(Term{id: 0, offset: start, value: Value::InstanceLiteral(instance)})
};

pub InstanceLiteralTerm: Rc<Term> = <InstanceLiteral<Exp5<"Term">>> => <>;
pub InstanceLiteralPattern: Rc<Term> = <InstanceLiteral<Exp9<"Pattern">>> => <>;

pub Pattern: Rc<Term> = {
    <term:InstanceLiteralPattern> => Pattern::term_as_pattern(term),
    <term:DictionaryPattern> => Pattern::term_as_pattern(term),
    <term:Number> => term,
    <term:PolarString> => term,
    <term:Boolean> => term,
    <term:Symbol> => term,
    <start:@L> "[" <terms:(<Pattern> ",")*> <term:Pattern?> "]" => {
        match term {
            Some(term) => Rc::new(Term{id:0, offset: start, value: Value::List(vec![term])}),
            None => Rc::new(Term{id: 0, offset: start, value: Value::List(terms)})
        }
    }
};

pub Term: Rc<Term> = {
    <term:Number> => term,
    <term:PolarString> => term,
    <term:Boolean> => term,
    <term:Symbol> => term,
    <term:DictionaryTerm> => term,
    <start:@L> <op:RewrittenOperation> => Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)}),
    <start:@L> <pred:Predicate> => Rc::new(Term{id: 0, offset: start, value: Value::Call(pred)}),
    <start:@L> "[" "]" => Rc::new(Term{id: 0, offset: start, value: Value::List(vec![])}),
    <start:@L> "[" <exp:TermExp> "]" => {
        let terms = unwrap_and(exp);
        Rc::new(Term{id:0, offset: start, value: Value::List(terms)})
    }
};

RewritableOperator: Operator = {
    "." => Operator::Dot,
    "new" => Operator::New,
    "in" => Operator::In,
    "debug" => Operator::Debug,
};

pub RewrittenOperation: Operation = {
    <op:RewritableOperator> "(" <args:TermExp> ")" => {
        let args = unwrap_and(args);
        Operation{operator: op, args: args}
    },
    <op:RewritableOperator> "(" ")" => {
        Operation{operator: op, args: vec![]}
    }
};

pub Predicate: Predicate = {
    <name:Name> "(" ")" => {
        let args = vec![];
        Predicate{name, args}
    },
    <name:Name> "(" <args:TermExp> ")" => {
        let args = unwrap_and(args);
        Predicate{name, args}
    }
};

Exp11<T>: Rc<Term> = {
    <term:Term> if T == "Term" => term,
    <term:Pattern> if T == "Pattern" => term,
    "(" <exp:Exp<T>> ")" => exp // seems sorta impossible to support parrens for expressions and list literals.
}

Exp10<T>: Rc<Term> = {
    // A pattern cannot contain a new operator
    <new:New> if T == "Term" => new,
    <start:@L> "cut" ( "(" ")" )? => {
        let args = vec![];
        let op = Operation{operator: Operator::Cut, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> "forall" "(" <arg1:Exp2<"Term">> "," <arg2:Exp2<"Term">> ")" => {
        let args = vec![arg1, arg2];
        let op = Operation{operator: Operator::ForAll, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp11:Exp11<T>> => exp11,
}

New: Rc<Term> = <start:@L> "new" <literal:InstanceLiteralTerm> => {
    let args = vec![literal];
    let op = Operation{operator: Operator::New, args};
    Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
};

Callable<T>: Rc<Term> = {
    <DictionaryTerm> if T == "Term" => <>,
    <DictionaryPattern> if T == "Pattern" => <>,
    <Symbol> => <>,
    <DotOp<T>> => <>,
    // A pattern cannot contain a new operator.
    <New> if T == "Term" => <>,
};

DotOp<T>: Rc<Term> = {
    <start:@L> <head:Callable<T>> "." <call_loc:@L> <mut call:Predicate> => {
        let call_term = Rc::new(Term{id: 0, offset: call_loc, value: Value::Call(call)});
        let args = vec![head, call_term];
        let op = Operation{operator: Operator::Dot, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <head:Callable<T>> "." <call_loc:@L> <name:Name> => {
        let call = Predicate{name, args: vec![]};
        let call_term = Rc::new(Term{id: 0, offset: call_loc, value: Value::Call(call)});
        let args = vec![head, call_term];
        let op = Operation{operator: Operator::Dot, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <head:Callable<T>> "." <call_loc:@L> "(" <name:Name> ")" => {
        let call_term = Rc::new(Term{id: 0, offset: call_loc, value: Value::Symbol(name)});
        let args = vec![head, call_term];
        let op = Operation{operator: Operator::Dot, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    }
}

// .
Exp9<T>: Rc<Term> = {
    <dot_op:DotOp<T>> => dot_op,
    <exp10:Exp10<T>> => exp10
};

// in isa
Exp8<T>: Rc<Term> = {
    <start:@L> <left:Exp8<T>> "in" <right:Exp9<T>> => {
        let args = vec![left, right];
        let op = Operation{operator: Operator::In, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    // Symbols on the RHS are treated as class names, just like in a specializers
    <start:@L> <left:Exp8<T>> "isa" <right:Pattern> => {
        let right = if let Value::Symbol(ref sym) = right.value {
            Rc::new(right.clone_with_value(Value::Pattern(Pattern::Instance(InstanceLiteral {
                tag: sym.clone(),
                fields: Dictionary::new()
            }))))
        } else {
            Pattern::term_as_pattern(right)
        };
        let args = vec![left, right];
        let op = Operation{operator: Operator::Isa, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp9:Exp9<T>> => exp9
}

// !
Exp7<T>: Rc<Term> = {
    <start:@L> "!" <exp8:Exp8<T>> => {
        let args = vec![exp8];
        let op = Operation{operator: Operator::Not, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    // TODO (dhatch): Maybe a different type here
    <exp8:Exp8<T>> => exp8
}

// * /
Exp6<T>: Rc<Term> = {
    <start:@L> <exp6:Exp6<T>> "*" <exp7:Exp7<T>> => {
        let args = vec![exp6, exp7];
        let op = Operation{operator: Operator::Mul, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp6:Exp6<T>> "/" <exp7:Exp7<T>> => {
        let args = vec![exp6, exp7];
        let op = Operation{operator: Operator::Div, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp7:Exp7<T>> => exp7
}

// + -
Exp5<T>: Rc<Term> = {
    <start:@L> <exp5:Exp5<T>> "+" <exp6:Exp6<T>> => {
        let args = vec![exp5, exp6];
        let op = Operation{operator: Operator::Add, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp5:Exp5<T>> "-" <exp6:Exp6<T>> => {
        let args = vec![exp5, exp6];
        let op = Operation{operator: Operator::Sub, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp6:Exp6<T>> => exp6
}

// == != <= < >= >
Exp4<T>: Rc<Term> = {
    <start:@L> <exp4:Exp4<T>> "==" <exp5:Exp5<T>> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Eq, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp4:Exp4<T>> "!=" <exp5:Exp5<T>> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Neq, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp4:Exp4<T>> "<=" <exp5:Exp5<T>> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Leq, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp4:Exp4<T>> ">=" <exp5:Exp5<T>> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Geq, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp4:Exp4<T>> "<" <exp5:Exp5<T>> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Lt, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <start:@L> <exp4:Exp4<T>> ">" <exp5:Exp5<T>> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Gt, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp5:Exp5<T>> => exp5
}

// =
Exp3<T>: Rc<Term> = {
    <start:@L> <exp3:Exp3<T>> "=" <exp4:Exp4<T>> => {
        let args = vec![exp3, exp4];
        let op = Operation{operator: Operator::Unify, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
     <exp4:Exp4<T>> => exp4
 }

// |
Exp2<T>: Rc<Term> = {
    <start:@L> <head:Exp3<T>> "|" <mut tail:Exp2<T>> => {
        let args = match tail.as_ref() {
            Term{value: Value::Expression(Operation{operator: Operator::Or, args: tail_args}), ..} => {
                let mut args = vec![head];
                args.append(&mut tail_args.clone());
                args
            }
            _ => {
                vec![head, tail]
            }
        };
        let op = Operation{operator: Operator::Or, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp3:Exp3<T>> => exp3
}

// ,
Exp1<T>: Rc<Term> = {
    <start:@L> <head:Exp2<T>> "," <mut tail:Exp1<T>> => {
        let args = match tail.as_ref() {
            Term{value: Value::Expression(Operation{operator: Operator::And, args: tail_args}), ..} => {
                let mut args = vec![head];
                args.append(&mut tail_args.clone());
                args
            }
            _ => {
                vec![head, tail]
            }
        };
        let op = Operation{operator: Operator::And, args};
        Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)})
    },
    <exp2:Exp2<T>> => exp2
}

// All ExpN & Exp productions are macros with one parameter. The parameter is the
// *string* "Term" or "Pattern" which controls whether the expression is over terms
// or patterns.  (It is a string since we need to conditionally
// change the expression precedence allowed in patterns versus terms depending
// on the parameter type, and LALRPOP does not allow conditional macros on anything
// other than a string.
Exp<T>: Rc<Term> = {
    <exp1:Exp1<T>> => exp1
}

Parameter: Parameter = {
    <param:Exp5<"Term">> => {
        Parameter{parameter: Some(param), specializer: None}
    },
    // parenthesized specializers do not have symbol translation to class names applied
    <start:@L> <name:Name> ":" "(" <specializer:Pattern> ")" => {
        let name = Rc::new(Term{id: 0, offset: start, value: Value::Symbol(name)});
        Parameter {
            parameter: Some(name),
            specializer: Some(specializer),
        }
    },
    <start:@L> <name:Name> ":" <specializer:Pattern> => {
        let name = Rc::new(Term{id: 0, offset: start, value: Value::Symbol(name)});
        if let Term{value: Value::Symbol(class_name), ..} = specializer.as_ref() {
            let fields = BTreeMap::new();
            let instance_literal = InstanceLiteral{tag: class_name.clone(), fields: Dictionary{fields}};
            Parameter {
                parameter: Some(name),
                specializer: Some(Rc::new(Term {
                    id: 0,
                    offset: start,
                    value: Value::Pattern(Pattern::Instance(instance_literal))
                }))
            }
        } else {
            Parameter{parameter: Some(name), specializer: Some(specializer)}
        }
    },
};

pub TermExp: Rc<Term> = {
    <Exp<"Term">> => <>
};

pub PatternExp: Rc<Term> = {
    <Exp9<"Pattern">> => <>
};

ParameterList: Vec<Parameter> = {
    <param:Parameter> => vec![param],
    <mut list:ParameterList> "," <param:Parameter> => {
        list.push(param);
        list
    },
};

RuleHead: (Symbol, Vec<Parameter>) = {
    <name:Name> "(" ")" => {
        (name, vec![])
    },
    <name:Name> "(" <params:ParameterList> ")" => {
        (name, params)
    }
};

pub Rule: Rule = {
    <head:RuleHead> <start:@L> ";" => {
        let (name, params) = head;
        let op = Operation{operator: Operator::And, args: vec![]};
        let body = Rc::new(Term{id: 0, offset: start, value: Value::Expression(op)});
        Rule{name, params, body}
    },
    <head:RuleHead> ":=" <body:TermExp> ";" => {
        let (name, params) = head;
        let body = match body.as_ref() {
            Term{value: Value::Expression(Operation{operator: Operator::And, ..}), ..} => {
                body.clone()
            },
            _ => {
                let offset = body.offset.clone();
                let op = Operation{operator: Operator::And, args: vec![body]};
                Rc::new(Term{id: 0, offset, value: Value::Expression(op)})
            }
        };
        Rule{name, params, body}
    }
}

pub Rules: Vec<Rule> = <Rule*>;

Line: Line = {
    <Rule> => Line::Rule(<>),
    "?=" <TermExp> ";" => Line::Query(<>),
}

pub Lines: Vec<Line> = <Line*>;
