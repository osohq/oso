// @NOTE(steve): This was pretty easy to get running but the error messages you get when things don't parse aren't as
// good as what we want to expose to polar users. Either we do a lot of mapping or we replace this with a hand rolled
// parser later.

use std::str::FromStr;
use std::collections::HashMap;
use crate::types::*;

use lalrpop_util::ParseError;

grammar;

pub Integer: Term = <start:@L> <s:r"[0-9]+"> => {
    Term{id: 0, offset: start, value: Value::Integer(i64::from_str(s).unwrap())}
};
// @TODO: Better string token.
pub PolarString: Term = <start:@L> <s:r#""(\\.|[^"\\])*""#> => {
    Term{id: 0, offset: start, value: Value::String(s[1..s.len()-1].to_string())}
};
True: Term = <start:@L> "true" => {
    Term{id: 0, offset: start, value: Value::Boolean(true)}
};
False: Term = <start:@L> "false" => {
    Term{id: 0, offset: start, value: Value::Boolean(true)}
};
pub Boolean: Term = {
    <bool:True> => bool,
    <bool:False> => bool
};
// @TODO: Better name token.
Name: Symbol = <s:r"[\w&&[^\d]]\w*"> => Symbol(s.to_string());

pub Symbol: Term  = <start:@L> <n:Name> => {
    Term{id: 0, offset: start, value: Value::Symbol(n)}
};

Fields: HashMap<Symbol, Term> = {
    <name:Name> ":" <value:Exp5> => {
        let mut fields = HashMap::new();
        fields.insert(name, value);
        fields
    },
    <name:Name> ":" <value:Exp5> "," <mut fields:Fields> => {
        fields.insert(name, value);
        fields
    }
};

pub Object: HashMap<Symbol, Term> = {
    "{" <fields:Fields> "}" => {
        fields
    },
    "{" "}" => {
        HashMap::new()
    }
};

pub Dictionary: Term = <start:@L> <fields:Object> => {
    let dict = Dictionary{fields};
    Term{id: 0, offset: start, value: Value::Dictionary(dict)}
};

pub InstanceLiteral: Term = <start:@L> <tag:Name> <fields:Object> => {
    let instance = InstanceLiteral{tag, fields: Dictionary{fields}};
    Term{id: 0, offset: start, value: Value::InstanceLiteral(instance)}
};

pub ExternalInstanceLiteral: Term = <start:@L> "^" <tag:Name> <fields:Object> => {
    let instance = InstanceLiteral{tag, fields: Dictionary{fields}};
    Term{id: 0, offset: start, value: Value::ExternalInstanceLiteral(instance)}
};

pub ExternalInstance: Term = <start:@L> "^" <fields:Object> => {
    let id = fields.get(&Symbol::new("id")).unwrap();
    if let Value::Integer(id) = id.value {
        let external_instance = ExternalInstance{instance_id: id as u64};
        Term{id: 0, offset: start, value: Value::ExternalInstance(external_instance)}
    } else {
        panic!("id must be an integer");
    }
};

pub Term: Term = {
    <term:Integer> => term,
    <term:PolarString> => term,
    <term:Boolean> => term,
    <term:Symbol> => term,
    <term:Dictionary> => term,
    <term:InstanceLiteral> => term,
    <term:ExternalInstanceLiteral> => term,
    <term:ExternalInstance> => term,
    <start:@L> <op:RewrittenOperation> => Term{id: 0, offset: start, value: Value::Expression(op)},
    <start:@L> <pred:Predicate> => Term{id: 0, offset: start, value: Value::Call(pred)},
    <start:@L> "[" "]" => Term{id: 0, offset: start, value: Value::List(vec![])},
    <start:@L> "[" <exp:Exp> "]" => {
        let terms = unwrap_and(exp);
        Term{id:0, offset: start, value: Value::List(terms)}
    }
};

RewritableOperator: Operator = {
    "." => Operator::Dot,
    "make" => Operator::Make
};

pub RewrittenOperation: Operation = {
    <op:RewritableOperator> "(" <args:Exp> ")" => {
        let args = unwrap_and(args);
        Operation{operator: op, args: args}
    }
};

pub Predicate: Predicate = {
    <name:Name> "(" ")" => {
        let args = vec![];
        Predicate{name, args}
    },
    <name:Name> "(" <args:Exp> ")" => {
        let args = unwrap_and(args);
        Predicate{name, args}
    }
};

Exp9: Term = {
    <term:Term> => term,
    "(" <exp:Exp> ")" => exp // seems sorta impossible to support parrens for expressions and list literals.
}

// @TODO: Think about this.
Callable: Term = {
    <ExternalInstance> => <>,
    <InstanceLiteral> => <>,
    <Dictionary> => <>,
    <Symbol> => <>,
    <DotOp> => <>,
};

DotOp: Term = {
    <start:@L> <head:Callable> "." <call_loc:@L> <mut call:Predicate> => {
        let call_term = Term{id: 0, offset: call_loc, value: Value::Call(call)};
        let args = vec![head, call_term];
        let op = Operation{operator: Operator::Dot, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <head:Callable> "." <call_loc:@L> <name:Name> => {
        let call = Predicate{name, args: vec![]};
        let call_term = Term{id: 0, offset: call_loc, value: Value::Call(call)};
        let args = vec![head, call_term];
        let op = Operation{operator: Operator::Dot, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
}

// .
Exp8: Term = {
    <dot_op:DotOp> => dot_op,
    <exp9:Exp9> => exp9
};

// !
Exp7: Term = {
    <start:@L> "!" <exp8:Exp8> => {
        let args = vec![exp8];
        let op = Operation{operator: Operator::Not, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <exp8:Exp8> => exp8
}

// * /
Exp6: Term = {
    <start:@L> <exp6:Exp6> "*" <exp7:Exp7> => {
        let args = vec![exp6, exp7];
        let op = Operation{operator: Operator::Mul, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp6:Exp6> "/" <exp7:Exp7> => {
        let args = vec![exp6, exp7];
        let op = Operation{operator: Operator::Div, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <exp7:Exp7> => exp7
}

// + -
pub Exp5: Term = {
    <start:@L> <exp5:Exp5> "+" <exp6:Exp6> => {
        let args = vec![exp5, exp6];
        let op = Operation{operator: Operator::Add, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp5:Exp5> "-" <exp6:Exp6> => {
        let args = vec![exp5, exp6];
        let op = Operation{operator: Operator::Sub, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <exp6:Exp6> => exp6
}

// == != <= < >= >
Exp4: Term = {
    <start:@L> <exp4:Exp4> "==" <exp5:Exp5> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Eq, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp4:Exp4> "!=" <exp5:Exp5> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Neq, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp4:Exp4> "<=" <exp5:Exp5> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Leq, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp4:Exp4> ">=" <exp5:Exp5> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Geq, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp4:Exp4> "<" <exp5:Exp5> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Lt, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <start:@L> <exp4:Exp4> ">" <exp5:Exp5> => {
        let args = vec![exp4, exp5];
        let op = Operation{operator: Operator::Gt, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <exp5:Exp5> => exp5
}

// =
Exp3: Term = {
    <start:@L> <exp3:Exp3> "=" <exp4:Exp4> => {
        let args = vec![exp3, exp4];
        let op = Operation{operator: Operator::Unify, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
     <exp4:Exp4> => exp4
 }

// |
Exp2: Term = {
    <start:@L> <head:Exp3> "|" <mut tail:Exp2> => {
        let args = match &mut tail {
            Term{id, offset, value: Value::Expression(Operation{operator: Operator::Or, args: tail_args})} => {
                let mut args = vec![head];
                args.append(tail_args);
                args
            }
            _ => {
                vec![head, tail]
            }
        };
        let op = Operation{operator: Operator::Or, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <exp3:Exp3> => exp3
}

// ,
Exp1: Term = {
    <start:@L> <head:Exp2> "," <mut tail:Exp1> => {
        let args = match &mut tail {
            Term{id, offset, value: Value::Expression(Operation{operator: Operator::And, args: tail_args})} => {
                let mut args = vec![head];
                args.append(tail_args);
                args
            }
            _ => {
                vec![head, tail]
            }
        };
        let op = Operation{operator: Operator::And, args};
        Term{id: 0, offset: start, value: Value::Expression(op)}
    },
    <exp2:Exp2> => exp2
}

pub Exp: Term = {
    <exp1:Exp1> => exp1
}

pub Rule: Rule = {
    <head:Predicate> <start:@L> ";" => {
        let name = head.name;
        let params = head.args;
        let op = Operation{operator: Operator::And, args: vec![]};
        let body = Term{id: 0, offset: start, value: Value::Expression(op)};
        Rule{name, params, body}
    },
    <head:Predicate> ":=" <body:Exp> ";" => {
        let name = head.name;
        let params = head.args;
        let body = match body {
            Term{value: Value::Expression(Operation{operator: Operator::And, ..}), ..} => {
                body
            },
            _ => {
                let offset = body.offset.clone();
                let op = Operation{operator: Operator::And, args: vec![body]};
                Term{id: 0, offset, value: Value::Expression(op)}
            }
        };
        Rule{name, params, body}
    }
}

pub Rules: Vec<Rule> = <Rule*>;
